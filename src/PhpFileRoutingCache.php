<?php declare(strict_types=1);

namespace AP\Routing\Cache;

use AP\Routing\Routing\Endpoint;
use AP\Routing\Routing\Routing\IndexInterface;
use RuntimeException;
use Throwable;
use UnexpectedValueException;

/**
 * Routing caching to a PHP file can be one of the most effective methods because OPcache optimizes performance
 */
class PhpFileRoutingCache implements RoutingCacheInterface
{
    /**
     * @param string $filename
     */
    public function __construct(protected string $filename)
    {
    }

    protected function getFilename(): string
    {
        return $this->filename;
    }

    /**
     * @return array
     * @throws UnexpectedValueException if not found
     * @throws Throwable all other errors
     */
    public function get(): array
    {
        $hashmap  = null;
        $filename = $this->getFilename();
        if (file_exists($filename)) {
            $routes = include($filename);
            if (is_array($routes)) {
                return $routes;
            }
            throw new RuntimeException("invalid data on the file: $filename");
        }
        throw new UnexpectedValueException("File not found: $filename");
    }

    private static function getClassAndMethodCallable(array|string $callable): array
    {
        if (!is_callable($callable)) {
            throw new RuntimeException(var_export($callable, true) . " is no callable");
        }

        if (is_string($callable)) {
            if (str_contains($callable, '::')) {
                $parts = explode('::', $callable);
                if (count($parts) == 2) {
                    return [$parts[0], $parts[1]];
                }
            }
        } elseif (count($callable) == 2) {
            return $callable;
        }
        throw new RuntimeException(
            "allowed only callable to methods, including class name and method name"
        );
    }

    private static function renderCallable(array|string $callable): string
    {
        $callable = self::getClassAndMethodCallable($callable);
        return "[\\$callable[0]::class, '$callable[1]']";
    }

    /**
     * @param IndexInterface $index
     * @param string|array $comments
     * @return void
     */
    public function set(IndexInterface $index, string|array $comments = []): void
    {
        $content = [
            "<?php declare(strict_types=1);",
            "/**",
            " * This file was generated by PhpFilePersistentCache. Please don't change it manually.",
        ];

        if (!empty($comments)) {
            if (is_string($comments)) {
                $comments = [$comments];
            }

            $content[] = " *";
            foreach ($comments as $comment) {
                $comment = trim($comment);
                if (!empty($comment)) {
                    $comment   = str_replace(
                        '*/',
                        '* /',
                        $comment
                    );
                    $content[] = " * " . $comment;
                }
            }
        }

        $content[] = " */";
        $content[] = "return [";

        $method_max_len = 0;
        foreach ($index->make() as $method => $endpoints) {
            $method_max_len = max($method_max_len, strlen($method));
        }
        foreach ($index->make() as $method => $endpoints) {
            $spaces    = $method_max_len - strlen($method);
            $spaces    = $spaces ? str_repeat(" ", $spaces) : "";
            $content[] = "    '$method'$spaces => [";

            $route_max_len_max_len = 0;
            foreach ($endpoints as $route => $serialized) {
                $route_max_len_max_len = max($route_max_len_max_len, strlen($route));
            }
            foreach ($endpoints as $route => $serialized) {
                $spaces   = $route_max_len_max_len - strlen($route);
                $spaces   = $spaces ? str_repeat(" ", $spaces) : "";
                $endpoint = Endpoint::deserialize($serialized);
                if (empty($endpoint->middleware)) {
                    $calableArray = self::renderCallable($endpoint->handler);
                    $content[]    = "        '" . addslashes($route) . "'$spaces => [$calableArray],";
                } else {
                    $endpointRenderArray = [];
                    foreach (array_merge([$endpoint->handler], $endpoint->middleware) as $el) {
                        $endpointRenderArray[] = self::renderCallable($el);
                    }
                    $endpointRenderArray = implode(", ", $endpointRenderArray);

                    $content[] = "        '" . addslashes($route) . "' => [$endpointRenderArray],";
                }
            }
            $content[] = "    ],";
        }

        $content[] = "];";

        $res = file_put_contents(
            $this->getFilename(),
            implode(
                "\n",
                $content,
            ),
        );
        if ($res === false) {
            throw new RuntimeException("Failed to write to file: {$this->getFilename()}");
        }
    }
}