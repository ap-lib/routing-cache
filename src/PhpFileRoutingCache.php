<?php declare(strict_types=1);

namespace AP\Routing\Cache;

use AP\Routing\Routing\Endpoint;
use AP\Routing\Routing\Routing\IndexInterface;
use RuntimeException;
use Throwable;
use UnexpectedValueException;

/**
 * Routing caching to a PHP file can be one of the most effective methods because OPcache optimizes performance
 */
class PhpFileRoutingCache implements RoutingCacheInterface
{
    /**
     * @param string $filename
     */
    public function __construct(protected string $filename)
    {
    }

    protected function getFilename(): string
    {
        return $this->filename;
    }

    /**
     * @return array
     * @throws UnexpectedValueException if not found
     * @throws Throwable all other errors
     */
    public function get(): array
    {
        $hashmap  = null;
        $filename = $this->getFilename();
        if (file_exists($filename)) {
            $routes = include($filename);
            if (is_array($routes)) {
                return $routes;
            }
            throw new RuntimeException("invalid data on the file: $filename");
        }
        throw new UnexpectedValueException("File not found: $filename");
    }

    private static function getClassAndMethodCallable(array|string $callable): array
    {
        if (!is_callable($callable)) {
            throw new RuntimeException(var_export($callable, true) . " is no callable");
        }

        if (is_string($callable)) {
            if (str_contains($callable, '::')) {
                $parts = explode('::', $callable);
                if (count($parts) == 2) {
                    return [$parts[0], $parts[1]];
                }
            }
        } elseif (count($callable) == 2) {
            return $callable;
        }
        throw new RuntimeException(
            "allowed only callable to methods, including class name and method name"
        );
    }

    private static function renderCallable(array|string $callable): string
    {
        $callable = self::getClassAndMethodCallable($callable);
        return "[\\$callable[0]::class, '$callable[1]']";
    }

    protected function renderArray(array $data, $nestedCount = 0, string $start = "", string $end = ""): array
    {
        $prefix  = str_repeat("    ", $nestedCount);
        $content = [];
        $max_len = 0;
        foreach ($data as $k => $v) {
            $max_len = max($max_len, strlen($k));
        }
        $content[] = "$prefix$start" . '[';
        foreach ($data as $k => $v) {
            $spaces = $max_len - strlen($k);
            $spaces = $spaces ? str_repeat(" ", $spaces) : "";
            foreach ($this->renderElement(
                $v,
                $nestedCount + 1,
                var_export($k, true) . "$spaces => ",
                ",") as $subEl
            ) {
                $content[] = $subEl;
            }
        }
        $content[] = "$prefix]$end";

        return $content;
    }

    protected function renderElement(mixed $el, $nestedCount = 0, string $start = "", string $end = ""): array
    {
        $prefix = str_repeat("    ", $nestedCount);

        if ((is_array($el) && isset($el[0]) && is_callable($el[0])) || is_string($el)) {
            $endpoint = Endpoint::deserialize($el);
            try {
                $endpoint->validateException();
                $endpointRenderArray = [];
                foreach (array_merge([$endpoint->handler], $endpoint->middleware) as $el) {
                    $endpointRenderArray[] = self::renderCallable($el);
                }
                return [$prefix . $start . '[' . implode(", ", $endpointRenderArray) . ']' . $end];

            } catch (UnexpectedValueException) {
            }
        }

        if (is_array($el)) {
            return $this->renderArray(
                $el,
                $nestedCount,
                $start,
                $end,
            );
        } elseif (is_string($el) || is_int($el) || is_float($el) || is_null($el) || is_bool($el)) {
            return [$prefix . $start . var_export($el, true) . $end];
        }
        throw new UnexpectedValueException();
    }

    /**
     * @param IndexInterface $index
     * @param string|array $comments
     * @return void
     */
    public function set(IndexInterface $index, string|array $comments = []): void
    {
        $content = [
            "<?php declare(strict_types=1);",
            "/**",
            " * This file was generated by PhpFilePersistentCache. Please don't change it manually.",
        ];

        if (!empty($comments)) {
            if (is_string($comments)) {
                $comments = [$comments];
            }

            $content[] = " *";
            foreach ($comments as $comment) {
                $comment = trim($comment);
                if (!empty($comment)) {
                    $comment   = str_replace(
                        '*/',
                        '* /',
                        $comment
                    );
                    $content[] = " * " . $comment;
                }
            }
        }

        $content[] = " */";

        $content = array_merge($content, $this->renderArray(
            $index->make(),
            0,
            "return ",
            ";"
        ));

        $res = file_put_contents(
            $this->getFilename(),
            implode(
                "\n",
                $content,
            ),
        );
        if ($res === false) {
            throw new RuntimeException("Failed to write to file: {$this->getFilename()}");
        }
    }
}